<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="description" content="Personal blog of Eric M Barnard">

    <title>SQL Script Generation Column Names</title>

    <link rel="canonical" href="/2011/08/sql-script-generation-column-names.html">

    
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-62268747-1', 'auto');
          ga('send', 'pageview');
        </script>
    

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="/css/site.css" type="text/css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Iterations</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
			      <li><a href="/">Home</a></li>
			    
			      <li><a href="/about">About</a></li>
			    
			      <li><a href="/consulting">Consulting</a></li>
			    
			      <li><a href="/archives">Archives</a></li>
			    
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
    
<!-- Post Header -->
<header class="intro-header" style="background-image: url('/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">s
                <div class="post-heading">
                    <h1>SQL Script Generation Column Names</h1>
                    
                </div>
            </div>
        </div>
    </div>
</header>


    <!-- Post Content -->
<article>
    <div class="container">
        <div  class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1>SQL Script Generation Column Names</h1>
                <span class="meta"><em>August 8th 2011</em></span>
                <hr/>
            </div>
        </div>
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<p>When I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.</p>
<p>Our head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.</p>
<p>The PROC allows you to specify:</p>
<ul>
<li>Table Name (as it appears in the SYS.tables table)</li>
<li>‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)</li>
<li>A ColumnName prefix (for doing table aliases)</li>
<li>A table schema (if you have other table schema’s besides ‘dbo’)</li>
</ul>
<p>Here’s the code (make sure to look at the bottom):<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">USE</span> [<span class="keyword">master</span>]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[sp_listcolumns]</span><br><span class="line">    @<span class="keyword">table</span>  SYSNAME,</span><br><span class="line">    @list   <span class="built_in">CHAR</span>(<span class="number">1</span>) = <span class="string">'L'</span>,</span><br><span class="line">    @prefix SYSNAME = <span class="string">''</span>,</span><br><span class="line">    @<span class="keyword">schema</span> SYSNAME = <span class="string">'dbo'</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SET</span> QUOTED_IDENTIFIER OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @columnlist <span class="keyword">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">       ,@colctr <span class="built_in">INT</span> = <span class="number">1</span></span><br><span class="line">       ,@sqlcmd <span class="keyword">NVARCHAR</span>(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #<span class="keyword">column</span></span><br><span class="line">(</span><br><span class="line">    ColumnName <span class="keyword">NVARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    Ordinal <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> IC_ColumnList99 <span class="keyword">ON</span> #<span class="keyword">column</span> (Ordinal)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @columnlist =    <span class="string">''</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">table</span> =        <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">table</span>))</span><br><span class="line"><span class="keyword">SET</span> @list =         <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@list))</span><br><span class="line"><span class="keyword">SET</span> @prefix =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@prefix))</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">schema</span> =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">schema</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> #<span class="keyword">column</span> (ColumnName, Ordinal)</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">'['</span>+<span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(COLUMN_NAME))+<span class="string">']'</span>, ORDINAL_POSITION</span><br><span class="line"><span class="keyword">FROM</span>    INFORMATION_SCHEMA.<span class="keyword">COLUMNS</span></span><br><span class="line"><span class="keyword">WHERE</span>   TABLE_NAME = @<span class="keyword">table</span> <span class="keyword">AND</span></span><br><span class="line">        TABLE_SCHEMA = @<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDINAL_POSITION</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check to make sure we actually got usuable input from the User</span></span><br><span class="line"><span class="keyword">IF</span> ((<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> #<span class="keyword">column</span>) = <span class="number">0</span>)</span><br><span class="line">RAISERROR(<span class="string">'Bad Table Information - Please Try Again'</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@prefix &lt;&gt; <span class="string">''</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> #<span class="keyword">column</span></span><br><span class="line">    <span class="keyword">SET</span>    ColumnName = @prefix + ColumnName</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@list = <span class="string">'L'</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- If it is 'L' just append a ',' to each line, output would be:</span></span><br><span class="line">        <span class="comment">-- TestCol1,</span></span><br><span class="line">        <span class="comment">-- TestCol2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">','</span> + <span class="built_in">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- else we output a 'w' where it just a ',' separated list of Column names</span></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">','</span></span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Remove the last comma</span></span><br><span class="line">        <span class="keyword">SET</span> @columnlist = <span class="keyword">LEFT</span>(@columnlist,<span class="keyword">LEN</span>(@columnlist) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output the results so that they can be nicely copy</span></span><br><span class="line"><span class="comment">-- and pasted from the comment window</span></span><br><span class="line">PRINT(@columnlist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure></p>
<p>Lastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">EXECUTE</span> sp_MS_marksystemobject <span class="string">'sp_listcolumns'</span></span></span><br></pre></td></tr></table></figure>
<p>After we have this proc build and added, we can get output like this:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Test</span><br><span class="line">(</span><br><span class="line">    Id UNIQUEIDENTIFIER</span><br><span class="line">    ,TestCol1 <span class="keyword">NVARCHAR</span>(<span class="number">64</span>)</span><br><span class="line">    ,TestCol2 <span class="built_in">INT</span></span><br><span class="line">    ,TestCol3 <span class="built_in">BIT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">'test'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],</span><br><span class="line">[TestCol1],</span><br><span class="line">[TestCol2],</span><br><span class="line">[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">'test'</span>,<span class="string">'w'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],[TestCol1],[TestCol2],[TestCol3]</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">'test'</span>,<span class="string">'l'</span>,<span class="string">'testTable.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],</span><br><span class="line">testTable.[TestCol1],</span><br><span class="line">testTable.[TestCol2],</span><br><span class="line">testTable.[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">'test'</span>,<span class="string">'w'</span>,<span class="string">'testTable.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]</span></span><br></pre></td></tr></table></figure></p>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2012/07/debugging-elmah-on-azure.html" data-toggle="tooltip" data-placement="top" title="Debugging Elmah on Azure">&larr; Previous Post</a>
                    </li>
                    
                    
                </ul>

            </div>
        </div>
        
            <div class="row">
                <div  id="disqus_wrapper" class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div id="disqus_thread"></div>
                    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                </div>
            </div>
        
    </div>
</article>

<hr>

    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/ericmbarnard">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="https://github.com/ericmbarnard">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Eric M Barnard 2015</p>
            </div>
        </div>
    </div>
</footer>

<!-- scripts -->
<script src="https://code.jquery.com/jquery-2.1.3.min.js" type="text/javascript"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js" type="text/javascript"></script>
<script src="/js/clean-blog.min.js?_=1429999115454" type="text/javascript" ></script>
<!-- disqus -->

    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES * * */
        var disqus_shortname = 'ericmbarnard';
        
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>



<!--
	config: {"title":"Iterations","subtitle":"Figuring it out... One step at a time.","description":"Personal blog of Eric M Barnard","author":"Eric M Barnard","language":"en-US","timezone":"America/Chicago","url":"http://ericmbarnard.com","root":"/","permalink":":year/:month/:title.html","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":year-:month-:day-:title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":1,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":false,"highlight":{"enable":true,"gutter":false,"tab":true},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"MMMM Do YYYY","time_format":"HH:mm:ss","per_page":10,"pagination_dir":"page","theme":"ericmbarnard-custom","deploy":{"type":"git","repo":"https://github.com/ericmbarnard/ericmbarnard.github.io.git","branch":"master"},"debug":1,"header_img":"/img/home-bg.jpg","archive_generator":{"per_page":0,"yearly":false,"monthly":false},"google_analytics":"UA-62268747-1","disqus_shortname":"ericmbarnard","github_username":"ericmbarnard","twitter_username":"ericmbarnard","clean_css":{"exclude":["*.min.css"]},"category_generator":{"per_page":10},"index_generator":{"per_page":10},"feed":{"type":"atom","limit":20,"path":"atom.xml"},"tag_generator":{"per_page":10},"server":{"port":4000,"log":false,"ip":"0.0.0.0"},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true}}
	page: { path: '2011/08/sql-script-generation-column-names.html',
  title: 'SQL Script Generation Column Names',
  date: 
   { [Number: 1312822800000]
     _isAMomentObject: true,
     _i: Mon Aug 08 2011 12:00:00 GMT-0500 (Central Daylight Time),
     _isUTC: true,
     _pf: 
      { empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false },
     _locale: 
      { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: [Function],
        _abbr: 'en',
        _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
     _d: Mon Aug 08 2011 07:00:00 GMT-0500 (Central Daylight Time),
     _z: 
      { name: 'America/Chicago',
        abbrs: [Object],
        untils: [Object],
        offsets: [Object] },
     _isValid: true,
     _offset: -300 },
  _content: '\nWhen I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.\n\nOur head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.\n\nThe PROC allows you to specify:\n- Table Name (as it appears in the SYS.tables table)\n- ‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)\n- A ColumnName prefix (for doing table aliases)\n- A table schema (if you have other table schema’s besides ‘dbo’)\n\nHere’s the code (make sure to look at the bottom):\n```sql\nUSE [master]\nGO\nSET ANSI_NULLS ON\nGO\nSET QUOTED_IDENTIFIER ON\nGO\nCREATE PROCEDURE [dbo].[sp_listcolumns]\n    @table  SYSNAME,\n    @list   CHAR(1) = \'L\',\n    @prefix SYSNAME = \'\',\n    @schema SYSNAME = \'dbo\'\nAS\nBEGIN\nSET NOCOUNT ON;\nSET QUOTED_IDENTIFIER OFF\n\nDECLARE @columnlist NVARCHAR(4000)\n       ,@colctr INT = 1\n       ,@sqlcmd NVARCHAR(500)\n\nCREATE TABLE #column\n(\n    ColumnName NVARCHAR(256),\n    Ordinal INT\n)\n\nCREATE UNIQUE CLUSTERED INDEX IC_ColumnList99 ON #column (Ordinal)\n\nSET @columnlist =    \'\'\nSET @table =        LTRIM(RTRIM(@table))\nSET @list =         LTRIM(RTRIM(@list))\nSET @prefix =       LTRIM(RTRIM(@prefix))\nSET @schema =       LTRIM(RTRIM(@schema))\n\nINSERT INTO #column (ColumnName, Ordinal)\nSELECT  \'[\'+LTRIM(RTRIM(COLUMN_NAME))+\']\', ORDINAL_POSITION\nFROM    INFORMATION_SCHEMA.COLUMNS\nWHERE   TABLE_NAME = @table AND\n        TABLE_SCHEMA = @schema\nORDER BY ORDINAL_POSITION\n\n-- Check to make sure we actually got usuable input from the User\nIF ((SELECT COUNT(*) FROM #column) = 0)\nRAISERROR(\'Bad Table Information - Please Try Again\', 16, 1, 1)\n\nIF(@prefix <> \'\')\nBEGIN\n    UPDATE #column\n    SET    ColumnName = @prefix + ColumnName\nEND\n\nIF(@list = \'L\')\n    BEGIN\n        -- If it is \'L\' just append a \',\' to each line, output would be:\n        -- TestCol1,\n        -- TestCol2\n\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\' + CHAR(10)\n        FROM    #column C\n    END\nELSE\n    BEGIN\n        -- else we output a \'w\' where it just a \',\' separated list of Column names\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\'\n        FROM    #column C\n\n        -- Remove the last comma\n        SET @columnlist = LEFT(@columnlist,LEN(@columnlist) - 1)\n    END\n\n-- Output the results so that they can be nicely copy\n-- and pasted from the comment window\nPRINT(@columnlist)\n\nSET QUOTED_IDENTIFIER ON\nSET NOCOUNT OFF\n\nEND\n```\n\nLastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in\n\n```sql\nEXECUTE sp_MS_marksystemobject \'sp_listcolumns\'\n```\n\nAfter we have this proc build and added, we can get output like this:\n```sql\nCREATE TABLE dbo.Test\n(\n    Id UNIQUEIDENTIFIER\n    ,TestCol1 NVARCHAR(64)\n    ,TestCol2 INT\n    ,TestCol3 BIT\n)\nGO\n\nsp_listcolumns \'test\'\n\n--Outputs:\n[Id],\n[TestCol1],\n[TestCol2],\n[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\'\n\n--Outputs:\n[Id],[TestCol1],[TestCol2],[TestCol3]\n--\n\nsp_listcolumns \'test\',\'l\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],\ntestTable.[TestCol1],\ntestTable.[TestCol2],\ntestTable.[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]\n```',
  source: '_posts/2011-08-08-sql-script-generation-column-names.md',
  raw: 'title: "SQL Script Generation Column Names"\ndate: 2011-08-8 12:00:00\ncategories: \n    - Development\ntags:\n    - SQL\n---\n\nWhen I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.\n\nOur head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.\n\nThe PROC allows you to specify:\n- Table Name (as it appears in the SYS.tables table)\n- ‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)\n- A ColumnName prefix (for doing table aliases)\n- A table schema (if you have other table schema’s besides ‘dbo’)\n\nHere’s the code (make sure to look at the bottom):\n```sql\nUSE [master]\nGO\nSET ANSI_NULLS ON\nGO\nSET QUOTED_IDENTIFIER ON\nGO\nCREATE PROCEDURE [dbo].[sp_listcolumns]\n    @table  SYSNAME,\n    @list   CHAR(1) = \'L\',\n    @prefix SYSNAME = \'\',\n    @schema SYSNAME = \'dbo\'\nAS\nBEGIN\nSET NOCOUNT ON;\nSET QUOTED_IDENTIFIER OFF\n\nDECLARE @columnlist NVARCHAR(4000)\n       ,@colctr INT = 1\n       ,@sqlcmd NVARCHAR(500)\n\nCREATE TABLE #column\n(\n    ColumnName NVARCHAR(256),\n    Ordinal INT\n)\n\nCREATE UNIQUE CLUSTERED INDEX IC_ColumnList99 ON #column (Ordinal)\n\nSET @columnlist =    \'\'\nSET @table =        LTRIM(RTRIM(@table))\nSET @list =         LTRIM(RTRIM(@list))\nSET @prefix =       LTRIM(RTRIM(@prefix))\nSET @schema =       LTRIM(RTRIM(@schema))\n\nINSERT INTO #column (ColumnName, Ordinal)\nSELECT  \'[\'+LTRIM(RTRIM(COLUMN_NAME))+\']\', ORDINAL_POSITION\nFROM    INFORMATION_SCHEMA.COLUMNS\nWHERE   TABLE_NAME = @table AND\n        TABLE_SCHEMA = @schema\nORDER BY ORDINAL_POSITION\n\n-- Check to make sure we actually got usuable input from the User\nIF ((SELECT COUNT(*) FROM #column) = 0)\nRAISERROR(\'Bad Table Information - Please Try Again\', 16, 1, 1)\n\nIF(@prefix <> \'\')\nBEGIN\n    UPDATE #column\n    SET    ColumnName = @prefix + ColumnName\nEND\n\nIF(@list = \'L\')\n    BEGIN\n        -- If it is \'L\' just append a \',\' to each line, output would be:\n        -- TestCol1,\n        -- TestCol2\n\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\' + CHAR(10)\n        FROM    #column C\n    END\nELSE\n    BEGIN\n        -- else we output a \'w\' where it just a \',\' separated list of Column names\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\'\n        FROM    #column C\n\n        -- Remove the last comma\n        SET @columnlist = LEFT(@columnlist,LEN(@columnlist) - 1)\n    END\n\n-- Output the results so that they can be nicely copy\n-- and pasted from the comment window\nPRINT(@columnlist)\n\nSET QUOTED_IDENTIFIER ON\nSET NOCOUNT OFF\n\nEND\n```\n\nLastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in\n\n```sql\nEXECUTE sp_MS_marksystemobject \'sp_listcolumns\'\n```\n\nAfter we have this proc build and added, we can get output like this:\n```sql\nCREATE TABLE dbo.Test\n(\n    Id UNIQUEIDENTIFIER\n    ,TestCol1 NVARCHAR(64)\n    ,TestCol2 INT\n    ,TestCol3 BIT\n)\nGO\n\nsp_listcolumns \'test\'\n\n--Outputs:\n[Id],\n[TestCol1],\n[TestCol2],\n[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\'\n\n--Outputs:\n[Id],[TestCol1],[TestCol2],[TestCol3]\n--\n\nsp_listcolumns \'test\',\'l\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],\ntestTable.[TestCol1],\ntestTable.[TestCol2],\ntestTable.[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]\n```',
  slug: 'sql-script-generation-column-names',
  published: true,
  updated: 
   { [Number: 1429981261559]
     _isAMomentObject: true,
     _i: Sat Apr 25 2015 12:01:01 GMT-0500 (Central Daylight Time),
     _isUTC: false,
     _pf: 
      { empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false },
     _locale: 
      { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: [Function],
        _abbr: 'en',
        _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
     _d: Sat Apr 25 2015 12:01:01 GMT-0500 (Central Daylight Time),
     _z: null },
  comments: true,
  layout: 'post',
  photos: [],
  link: '',
  content: '<p>When I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.</p>\n<p>Our head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.</p>\n<p>The PROC allows you to specify:</p>\n<ul>\n<li>Table Name (as it appears in the SYS.tables table)</li>\n<li>‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)</li>\n<li>A ColumnName prefix (for doing table aliases)</li>\n<li>A table schema (if you have other table schema’s besides ‘dbo’)</li>\n</ul>\n<p>Here’s the code (make sure to look at the bottom):<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">USE</span> [<span class="keyword">master</span>]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[sp_listcolumns]</span><br><span class="line">    @<span class="keyword">table</span>  SYSNAME,</span><br><span class="line">    @list   <span class="built_in">CHAR</span>(<span class="number">1</span>) = <span class="string">\'L\'</span>,</span><br><span class="line">    @prefix SYSNAME = <span class="string">\'\'</span>,</span><br><span class="line">    @<span class="keyword">schema</span> SYSNAME = <span class="string">\'dbo\'</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SET</span> QUOTED_IDENTIFIER OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @columnlist <span class="keyword">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">       ,@colctr <span class="built_in">INT</span> = <span class="number">1</span></span><br><span class="line">       ,@sqlcmd <span class="keyword">NVARCHAR</span>(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #<span class="keyword">column</span></span><br><span class="line">(</span><br><span class="line">    ColumnName <span class="keyword">NVARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    Ordinal <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> IC_ColumnList99 <span class="keyword">ON</span> #<span class="keyword">column</span> (Ordinal)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @columnlist =    <span class="string">\'\'</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">table</span> =        <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">table</span>))</span><br><span class="line"><span class="keyword">SET</span> @list =         <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@list))</span><br><span class="line"><span class="keyword">SET</span> @prefix =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@prefix))</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">schema</span> =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">schema</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> #<span class="keyword">column</span> (ColumnName, Ordinal)</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">\'[\'</span>+<span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(COLUMN_NAME))+<span class="string">\']\'</span>, ORDINAL_POSITION</span><br><span class="line"><span class="keyword">FROM</span>    INFORMATION_SCHEMA.<span class="keyword">COLUMNS</span></span><br><span class="line"><span class="keyword">WHERE</span>   TABLE_NAME = @<span class="keyword">table</span> <span class="keyword">AND</span></span><br><span class="line">        TABLE_SCHEMA = @<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDINAL_POSITION</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check to make sure we actually got usuable input from the User</span></span><br><span class="line"><span class="keyword">IF</span> ((<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> #<span class="keyword">column</span>) = <span class="number">0</span>)</span><br><span class="line">RAISERROR(<span class="string">\'Bad Table Information - Please Try Again\'</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@prefix &lt;&gt; <span class="string">\'\'</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> #<span class="keyword">column</span></span><br><span class="line">    <span class="keyword">SET</span>    ColumnName = @prefix + ColumnName</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@list = <span class="string">\'L\'</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- If it is \'L\' just append a \',\' to each line, output would be:</span></span><br><span class="line">        <span class="comment">-- TestCol1,</span></span><br><span class="line">        <span class="comment">-- TestCol2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span> + <span class="built_in">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- else we output a \'w\' where it just a \',\' separated list of Column names</span></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span></span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Remove the last comma</span></span><br><span class="line">        <span class="keyword">SET</span> @columnlist = <span class="keyword">LEFT</span>(@columnlist,<span class="keyword">LEN</span>(@columnlist) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output the results so that they can be nicely copy</span></span><br><span class="line"><span class="comment">-- and pasted from the comment window</span></span><br><span class="line">PRINT(@columnlist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure></p>\n<p>Lastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in</p>\n<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">EXECUTE</span> sp_MS_marksystemobject <span class="string">\'sp_listcolumns\'</span></span></span><br></pre></td></tr></table></figure>\n<p>After we have this proc build and added, we can get output like this:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Test</span><br><span class="line">(</span><br><span class="line">    Id UNIQUEIDENTIFIER</span><br><span class="line">    ,TestCol1 <span class="keyword">NVARCHAR</span>(<span class="number">64</span>)</span><br><span class="line">    ,TestCol2 <span class="built_in">INT</span></span><br><span class="line">    ,TestCol3 <span class="built_in">BIT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],</span><br><span class="line">[TestCol1],</span><br><span class="line">[TestCol2],</span><br><span class="line">[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],[TestCol1],[TestCol2],[TestCol3]</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'l\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],</span><br><span class="line">testTable.[TestCol1],</span><br><span class="line">testTable.[TestCol2],</span><br><span class="line">testTable.[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]</span></span><br></pre></td></tr></table></figure></p>\n',
  excerpt: '',
  more: '<p>When I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.</p>\n<p>Our head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.</p>\n<p>The PROC allows you to specify:</p>\n<ul>\n<li>Table Name (as it appears in the SYS.tables table)</li>\n<li>‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)</li>\n<li>A ColumnName prefix (for doing table aliases)</li>\n<li>A table schema (if you have other table schema’s besides ‘dbo’)</li>\n</ul>\n<p>Here’s the code (make sure to look at the bottom):<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">USE</span> [<span class="keyword">master</span>]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[sp_listcolumns]</span><br><span class="line">    @<span class="keyword">table</span>  SYSNAME,</span><br><span class="line">    @list   <span class="built_in">CHAR</span>(<span class="number">1</span>) = <span class="string">\'L\'</span>,</span><br><span class="line">    @prefix SYSNAME = <span class="string">\'\'</span>,</span><br><span class="line">    @<span class="keyword">schema</span> SYSNAME = <span class="string">\'dbo\'</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SET</span> QUOTED_IDENTIFIER OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @columnlist <span class="keyword">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">       ,@colctr <span class="built_in">INT</span> = <span class="number">1</span></span><br><span class="line">       ,@sqlcmd <span class="keyword">NVARCHAR</span>(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #<span class="keyword">column</span></span><br><span class="line">(</span><br><span class="line">    ColumnName <span class="keyword">NVARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    Ordinal <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> IC_ColumnList99 <span class="keyword">ON</span> #<span class="keyword">column</span> (Ordinal)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @columnlist =    <span class="string">\'\'</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">table</span> =        <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">table</span>))</span><br><span class="line"><span class="keyword">SET</span> @list =         <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@list))</span><br><span class="line"><span class="keyword">SET</span> @prefix =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@prefix))</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">schema</span> =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">schema</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> #<span class="keyword">column</span> (ColumnName, Ordinal)</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">\'[\'</span>+<span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(COLUMN_NAME))+<span class="string">\']\'</span>, ORDINAL_POSITION</span><br><span class="line"><span class="keyword">FROM</span>    INFORMATION_SCHEMA.<span class="keyword">COLUMNS</span></span><br><span class="line"><span class="keyword">WHERE</span>   TABLE_NAME = @<span class="keyword">table</span> <span class="keyword">AND</span></span><br><span class="line">        TABLE_SCHEMA = @<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDINAL_POSITION</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check to make sure we actually got usuable input from the User</span></span><br><span class="line"><span class="keyword">IF</span> ((<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> #<span class="keyword">column</span>) = <span class="number">0</span>)</span><br><span class="line">RAISERROR(<span class="string">\'Bad Table Information - Please Try Again\'</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@prefix &lt;&gt; <span class="string">\'\'</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> #<span class="keyword">column</span></span><br><span class="line">    <span class="keyword">SET</span>    ColumnName = @prefix + ColumnName</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@list = <span class="string">\'L\'</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- If it is \'L\' just append a \',\' to each line, output would be:</span></span><br><span class="line">        <span class="comment">-- TestCol1,</span></span><br><span class="line">        <span class="comment">-- TestCol2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span> + <span class="built_in">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- else we output a \'w\' where it just a \',\' separated list of Column names</span></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span></span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Remove the last comma</span></span><br><span class="line">        <span class="keyword">SET</span> @columnlist = <span class="keyword">LEFT</span>(@columnlist,<span class="keyword">LEN</span>(@columnlist) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output the results so that they can be nicely copy</span></span><br><span class="line"><span class="comment">-- and pasted from the comment window</span></span><br><span class="line">PRINT(@columnlist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure></p>\n<p>Lastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in</p>\n<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">EXECUTE</span> sp_MS_marksystemobject <span class="string">\'sp_listcolumns\'</span></span></span><br></pre></td></tr></table></figure>\n<p>After we have this proc build and added, we can get output like this:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Test</span><br><span class="line">(</span><br><span class="line">    Id UNIQUEIDENTIFIER</span><br><span class="line">    ,TestCol1 <span class="keyword">NVARCHAR</span>(<span class="number">64</span>)</span><br><span class="line">    ,TestCol2 <span class="built_in">INT</span></span><br><span class="line">    ,TestCol3 <span class="built_in">BIT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],</span><br><span class="line">[TestCol1],</span><br><span class="line">[TestCol2],</span><br><span class="line">[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],[TestCol1],[TestCol2],[TestCol3]</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'l\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],</span><br><span class="line">testTable.[TestCol1],</span><br><span class="line">testTable.[TestCol2],</span><br><span class="line">testTable.[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]</span></span><br></pre></td></tr></table></figure></p>\n',
  _id: 'ci8xkju9200002wtb0dnckq7o',
  permalink: 'http://ericmbarnard.com/2011/08/sql-script-generation-column-names.html',
  full_source: 'C:\\git\\ericmbarnard.github.io-hexo\\source\\_posts\\2011-08-08-sql-script-generation-column-names.md',
  asset_dir: 'C:\\git\\ericmbarnard.github.io-hexo\\source\\_posts\\2011-08-08-sql-script-generation-column-names\\',
  tags: { data: [ [Object] ], length: 1 },
  categories: { data: [ [Object] ], length: 1 },
  prev: 
   { title: 'Debugging Elmah on Azure',
     subtitle: 'What do you do when the error handler is erroring...',
     date: 
      { [Number: 1343736000000]
        _isAMomentObject: true,
        _i: Tue Jul 31 2012 07:00:00 GMT-0500 (Central Daylight Time),
        _isUTC: true,
        _pf: [Object],
        _locale: [Object],
        _d: Tue Jul 31 2012 02:00:00 GMT-0500 (Central Daylight Time),
        _z: [Object],
        _isValid: true,
        _offset: -300 },
     _content: '\nRecently I was deploying an application to the new Azure Websites service, and I noticed a slight problem with my app.\n\nELMAH worked on my machine, but not in the cloud.\n\nNeedless to say, if your exception logging isn\'t working, then you\'re probably not going to sleep well at night. So my first question, naturally, was "How in the world do I see what is going on inside ELMAH?".\n\nOne thing that many folks don\'t realize until they need to do something like this is that logging libraries tend to "eat" many of their internal exceptions since they are usually the layer that is added to take care of exactly that. I say they "eat" their exceptions not in a strict sense, but more so because there really is no where you can do a "TRY CATCH" to see what is happening.\n\n##Tracing to the Rescue\n\nInstead of throwing exceptions both ELMAH and Log4net output their exceptions to the System.Diagnostics.Trace object. This is sweet when debugging locally, as any application traces will automatically write to the Output window in Visual Studio. But as the title of this post reads, that doesn\'t help me at all.\n\nI needed to figure out how to output the traces of my app running in Azure to some storage that I could then view. I did have Log4net working, and it was writing to an SQL Azure database, so I decided to go with that option.\n\nFirst, I had to learn a few things about ASP.NET and Tracing. ASP.NET has its own tracing mechanism that is somewhat separate from the Diagnostics Tracing (which you can read about here). I could try to write the Diagnostic Trace messages out to the ASP.NET Page Trace mechanism, but in MVC (which I\'m using), it doesn\'t really work. So, honestly my best bet is to write to a database (as writing to a file in the cloud is not very reliable) using a TraceListener class setup to redirect Trace messages to Log4net\'s log.\n\nMy TraceListener looked like this:\n\n```csharp\nusing System.Diagnostics\n\npublic class Log4netTraceListener : TraceListener\n{\n    private static readonly log4net.ILog _log;\n\n    public Log4netTraceListener()\n    {\n        _log = log4net.LogManager.GetLogger(typeof(Log4netTraceListener));\n    }\n\n    public override void Write(string message)\n    {\n        if (_log != null)\n        {\n            _log.Debug(message);\n        }\n    }\n\n    public override void WriteLine(string message)\n    {\n        if (_log != null)\n        {\n            _log.Debug(message);\n        }\n    }\n}\n```\n\nNow, I first tried adding my Log4netTraceListener in the web.config. However, this Listener is initialized and added to the "Trace.Listeners" collection before Log4net has initialized in my web application. So instead, I have to add it programmatically during the application startup. I did the following in my Global.asax.cs:\n\n```csharp\nSystem.Diagnostics.Trace.Listeners.Add(new Log4netTraceListener());\n```\n\nAfter all of that, I finally started seeing the following in my Log4net log:\n> System.Data.SqlClient.SqlException (0x80131904): Tables without a clustered index are not supported in this version of SQL Server. Please create a clustered index and try again.\n\nWhoa, that is not something I expected to see. Apparently the "ELMAH_Error" table has a non-clustered primary key and no clustered index on the table (not really sure why). So we have two options:\n1. Add another column to the table and setup a clustered index on that column.\n2. The "Sequence" column is already an "int IDENTITY(1,1)" column - so just setup a clustered index on that column.\n\nI chose option 2. And here\'s the change to apply after executing the default [ELMAH SQL Script](https://code.google.com/p/elmah/source/browse/src/Elmah/SQLServer.sql):\n\n```sql\nCREATE CLUSTERED INDEX [IC_Elmah_Sequence] on dbo.[ELMAH_Error] (Sequence)\n```',
     source: '_posts/2012-07-31-debugging-elmah-on-azure.md',
     raw: '---\ntitle: Debugging Elmah on Azure\nsubtitle: "What do you do when the error handler is erroring..."\ndate: "2012-07-31T12:00:00"\ntags: SQL, Azure\n---\n\nRecently I was deploying an application to the new Azure Websites service, and I noticed a slight problem with my app.\n\nELMAH worked on my machine, but not in the cloud.\n\nNeedless to say, if your exception logging isn\'t working, then you\'re probably not going to sleep well at night. So my first question, naturally, was "How in the world do I see what is going on inside ELMAH?".\n\nOne thing that many folks don\'t realize until they need to do something like this is that logging libraries tend to "eat" many of their internal exceptions since they are usually the layer that is added to take care of exactly that. I say they "eat" their exceptions not in a strict sense, but more so because there really is no where you can do a "TRY CATCH" to see what is happening.\n\n##Tracing to the Rescue\n\nInstead of throwing exceptions both ELMAH and Log4net output their exceptions to the System.Diagnostics.Trace object. This is sweet when debugging locally, as any application traces will automatically write to the Output window in Visual Studio. But as the title of this post reads, that doesn\'t help me at all.\n\nI needed to figure out how to output the traces of my app running in Azure to some storage that I could then view. I did have Log4net working, and it was writing to an SQL Azure database, so I decided to go with that option.\n\nFirst, I had to learn a few things about ASP.NET and Tracing. ASP.NET has its own tracing mechanism that is somewhat separate from the Diagnostics Tracing (which you can read about here). I could try to write the Diagnostic Trace messages out to the ASP.NET Page Trace mechanism, but in MVC (which I\'m using), it doesn\'t really work. So, honestly my best bet is to write to a database (as writing to a file in the cloud is not very reliable) using a TraceListener class setup to redirect Trace messages to Log4net\'s log.\n\nMy TraceListener looked like this:\n\n```csharp\nusing System.Diagnostics\n\npublic class Log4netTraceListener : TraceListener\n{\n    private static readonly log4net.ILog _log;\n\n    public Log4netTraceListener()\n    {\n        _log = log4net.LogManager.GetLogger(typeof(Log4netTraceListener));\n    }\n\n    public override void Write(string message)\n    {\n        if (_log != null)\n        {\n            _log.Debug(message);\n        }\n    }\n\n    public override void WriteLine(string message)\n    {\n        if (_log != null)\n        {\n            _log.Debug(message);\n        }\n    }\n}\n```\n\nNow, I first tried adding my Log4netTraceListener in the web.config. However, this Listener is initialized and added to the "Trace.Listeners" collection before Log4net has initialized in my web application. So instead, I have to add it programmatically during the application startup. I did the following in my Global.asax.cs:\n\n```csharp\nSystem.Diagnostics.Trace.Listeners.Add(new Log4netTraceListener());\n```\n\nAfter all of that, I finally started seeing the following in my Log4net log:\n> System.Data.SqlClient.SqlException (0x80131904): Tables without a clustered index are not supported in this version of SQL Server. Please create a clustered index and try again.\n\nWhoa, that is not something I expected to see. Apparently the "ELMAH_Error" table has a non-clustered primary key and no clustered index on the table (not really sure why). So we have two options:\n1. Add another column to the table and setup a clustered index on that column.\n2. The "Sequence" column is already an "int IDENTITY(1,1)" column - so just setup a clustered index on that column.\n\nI chose option 2. And here\'s the change to apply after executing the default [ELMAH SQL Script](https://code.google.com/p/elmah/source/browse/src/Elmah/SQLServer.sql):\n\n```sql\nCREATE CLUSTERED INDEX [IC_Elmah_Sequence] on dbo.[ELMAH_Error] (Sequence)\n```',
     slug: 'debugging-elmah-on-azure',
     published: true,
     updated: 
      { [Number: 1429965653459]
        _isAMomentObject: true,
        _i: Sat Apr 25 2015 07:40:53 GMT-0500 (Central Daylight Time),
        _isUTC: false,
        _pf: [Object],
        _locale: [Object],
        _d: Sat Apr 25 2015 07:40:53 GMT-0500 (Central Daylight Time),
        _z: null },
     comments: true,
     layout: 'post',
     photos: [],
     link: '',
     content: '<p>Recently I was deploying an application to the new Azure Websites service, and I noticed a slight problem with my app.</p>\n<p>ELMAH worked on my machine, but not in the cloud.</p>\n<p>Needless to say, if your exception logging isn’t working, then you’re probably not going to sleep well at night. So my first question, naturally, was “How in the world do I see what is going on inside ELMAH?”.</p>\n<p>One thing that many folks don’t realize until they need to do something like this is that logging libraries tend to “eat” many of their internal exceptions since they are usually the layer that is added to take care of exactly that. I say they “eat” their exceptions not in a strict sense, but more so because there really is no where you can do a “TRY CATCH” to see what is happening.</p>\n<h2 id="Tracing_to_the_Rescue">Tracing to the Rescue</h2><p>Instead of throwing exceptions both ELMAH and Log4net output their exceptions to the System.Diagnostics.Trace object. This is sweet when debugging locally, as any application traces will automatically write to the Output window in Visual Studio. But as the title of this post reads, that doesn’t help me at all.</p>\n<p>I needed to figure out how to output the traces of my app running in Azure to some storage that I could then view. I did have Log4net working, and it was writing to an SQL Azure database, so I decided to go with that option.</p>\n<p>First, I had to learn a few things about ASP.NET and Tracing. ASP.NET has its own tracing mechanism that is somewhat separate from the Diagnostics Tracing (which you can read about here). I could try to write the Diagnostic Trace messages out to the ASP.NET Page Trace mechanism, but in MVC (which I’m using), it doesn’t really work. So, honestly my best bet is to write to a database (as writing to a file in the cloud is not very reliable) using a TraceListener class setup to redirect Trace messages to Log4net’s log.</p>\n<p>My TraceListener looked like this:</p>\n<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Log4netTraceListener</span> : <span class="title">TraceListener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> log4net.ILog _log;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4netTraceListener</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        _log = log4net.LogManager.GetLogger(<span class="keyword">typeof</span>(Log4netTraceListener));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">string</span> message)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_log != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _log.Debug(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteLine</span><span class="params">(<span class="keyword">string</span> message)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_log != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _log.Debug(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>\n<p>Now, I first tried adding my Log4netTraceListener in the web.config. However, this Listener is initialized and added to the “Trace.Listeners” collection before Log4net has initialized in my web application. So instead, I have to add it programmatically during the application startup. I did the following in my Global.asax.cs:</p>\n<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.Diagnostics.Trace.Listeners.Add(<span class="keyword">new</span> Log4netTraceListener());</span><br></pre></td></tr></table></figure>\n<p>After all of that, I finally started seeing the following in my Log4net log:</p>\n<blockquote>\n<p>System.Data.SqlClient.SqlException (0x80131904): Tables without a clustered index are not supported in this version of SQL Server. Please create a clustered index and try again.</p>\n</blockquote>\n<p>Whoa, that is not something I expected to see. Apparently the “ELMAH_Error” table has a non-clustered primary key and no clustered index on the table (not really sure why). So we have two options:</p>\n<ol>\n<li>Add another column to the table and setup a clustered index on that column.</li>\n<li>The “Sequence” column is already an “int IDENTITY(1,1)” column - so just setup a clustered index on that column.</li>\n</ol>\n<p>I chose option 2. And here’s the change to apply after executing the default <a href="https://code.google.com/p/elmah/source/browse/src/Elmah/SQLServer.sql" target="_blank" rel="external">ELMAH SQL Script</a>:</p>\n<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> CLUSTERED <span class="keyword">INDEX</span> [IC_Elmah_Sequence] <span class="keyword">on</span> dbo.[ELMAH_Error] (Sequence)</span></span><br></pre></td></tr></table></figure>',
     excerpt: '',
     more: '<p>Recently I was deploying an application to the new Azure Websites service, and I noticed a slight problem with my app.</p>\n<p>ELMAH worked on my machine, but not in the cloud.</p>\n<p>Needless to say, if your exception logging isn’t working, then you’re probably not going to sleep well at night. So my first question, naturally, was “How in the world do I see what is going on inside ELMAH?”.</p>\n<p>One thing that many folks don’t realize until they need to do something like this is that logging libraries tend to “eat” many of their internal exceptions since they are usually the layer that is added to take care of exactly that. I say they “eat” their exceptions not in a strict sense, but more so because there really is no where you can do a “TRY CATCH” to see what is happening.</p>\n<h2 id="Tracing_to_the_Rescue">Tracing to the Rescue</h2><p>Instead of throwing exceptions both ELMAH and Log4net output their exceptions to the System.Diagnostics.Trace object. This is sweet when debugging locally, as any application traces will automatically write to the Output window in Visual Studio. But as the title of this post reads, that doesn’t help me at all.</p>\n<p>I needed to figure out how to output the traces of my app running in Azure to some storage that I could then view. I did have Log4net working, and it was writing to an SQL Azure database, so I decided to go with that option.</p>\n<p>First, I had to learn a few things about ASP.NET and Tracing. ASP.NET has its own tracing mechanism that is somewhat separate from the Diagnostics Tracing (which you can read about here). I could try to write the Diagnostic Trace messages out to the ASP.NET Page Trace mechanism, but in MVC (which I’m using), it doesn’t really work. So, honestly my best bet is to write to a database (as writing to a file in the cloud is not very reliable) using a TraceListener class setup to redirect Trace messages to Log4net’s log.</p>\n<p>My TraceListener looked like this:</p>\n<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Log4netTraceListener</span> : <span class="title">TraceListener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> log4net.ILog _log;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Log4netTraceListener</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        _log = log4net.LogManager.GetLogger(<span class="keyword">typeof</span>(Log4netTraceListener));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">string</span> message)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_log != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _log.Debug(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">WriteLine</span><span class="params">(<span class="keyword">string</span> message)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_log != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _log.Debug(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>\n<p>Now, I first tried adding my Log4netTraceListener in the web.config. However, this Listener is initialized and added to the “Trace.Listeners” collection before Log4net has initialized in my web application. So instead, I have to add it programmatically during the application startup. I did the following in my Global.asax.cs:</p>\n<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">System.Diagnostics.Trace.Listeners.Add(<span class="keyword">new</span> Log4netTraceListener());</span><br></pre></td></tr></table></figure>\n<p>After all of that, I finally started seeing the following in my Log4net log:</p>\n<blockquote>\n<p>System.Data.SqlClient.SqlException (0x80131904): Tables without a clustered index are not supported in this version of SQL Server. Please create a clustered index and try again.</p>\n</blockquote>\n<p>Whoa, that is not something I expected to see. Apparently the “ELMAH_Error” table has a non-clustered primary key and no clustered index on the table (not really sure why). So we have two options:</p>\n<ol>\n<li>Add another column to the table and setup a clustered index on that column.</li>\n<li>The “Sequence” column is already an “int IDENTITY(1,1)” column - so just setup a clustered index on that column.</li>\n</ol>\n<p>I chose option 2. And here’s the change to apply after executing the default <a href="https://code.google.com/p/elmah/source/browse/src/Elmah/SQLServer.sql">ELMAH SQL Script</a>:</p>\n<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> CLUSTERED <span class="keyword">INDEX</span> [IC_Elmah_Sequence] <span class="keyword">on</span> dbo.[ELMAH_Error] (Sequence)</span></span><br></pre></td></tr></table></figure>',
     _id: 'ci8xkju9n00092wtbhrm41l8n',
     path: [Getter],
     permalink: [Getter],
     full_source: [Getter],
     asset_dir: [Getter],
     tags: [Getter],
     categories: [Getter],
     prev: 
      { title: 'My First Book is Out',
        subtitle: 'I published my first book - KnockoutJS Starter',
        date: [Object],
        _content: '\n{% img /images/my_first_book_is_out.jpg %}\n\nI\'m pretty excited to announce that my first book, [KnockoutJS Starter](http://www.packtpub.com/knockoutjs-starter/book), was recently published. If my blog looked dead for the past several months, it was due to this little project (and a few other things).\n\nPlease check it out and leave any feedback/comments here. I would like to write another JavaScript book and constructive feedback would be really appreciated!\n\n[KnockoutJS Starter](http://www.packtpub.com/knockoutjs-starter/book) - Publisher Site\n[KnockoutJS Starter](http://www.amazon.com/KnockoutJS-Starter-ebook/dp/B00AC1HDJS/) - Amazon',
        source: '_posts/2013-01-01-my-first-book-is-out.md',
        raw: '---\ntitle: "My First Book is Out"\nsubtitle: "I published my first book - KnockoutJS Starter"\ndate: "2013-01-06T21:20:00"\ntags:\n---\n\n{% img /images/my_first_book_is_out.jpg %}\n\nI\'m pretty excited to announce that my first book, [KnockoutJS Starter](http://www.packtpub.com/knockoutjs-starter/book), was recently published. If my blog looked dead for the past several months, it was due to this little project (and a few other things).\n\nPlease check it out and leave any feedback/comments here. I would like to write another JavaScript book and constructive feedback would be really appreciated!\n\n[KnockoutJS Starter](http://www.packtpub.com/knockoutjs-starter/book) - Publisher Site\n[KnockoutJS Starter](http://www.amazon.com/KnockoutJS-Starter-ebook/dp/B00AC1HDJS/) - Amazon',
        slug: 'my-first-book-is-out',
        published: true,
        updated: [Object],
        comments: true,
        layout: 'post',
        photos: [],
        link: '',
        content: '<img src="/images/my_first_book_is_out.jpg">\n<p>I’m pretty excited to announce that my first book, <a href="http://www.packtpub.com/knockoutjs-starter/book" target="_blank" rel="external">KnockoutJS Starter</a>, was recently published. If my blog looked dead for the past several months, it was due to this little project (and a few other things).</p>\n<p>Please check it out and leave any feedback/comments here. I would like to write another JavaScript book and constructive feedback would be really appreciated!</p>\n<p><a href="http://www.packtpub.com/knockoutjs-starter/book" target="_blank" rel="external">KnockoutJS Starter</a> - Publisher Site<br><a href="http://www.amazon.com/KnockoutJS-Starter-ebook/dp/B00AC1HDJS/" target="_blank" rel="external">KnockoutJS Starter</a> - Amazon</p>\n',
        excerpt: '',
        more: '<img src="/images/my_first_book_is_out.jpg">\n<p>I’m pretty excited to announce that my first book, <a href="http://www.packtpub.com/knockoutjs-starter/book">KnockoutJS Starter</a>, was recently published. If my blog looked dead for the past several months, it was due to this little project (and a few other things).</p>\n<p>Please check it out and leave any feedback/comments here. I would like to write another JavaScript book and constructive feedback would be really appreciated!</p>\n<p><a href="http://www.packtpub.com/knockoutjs-starter/book">KnockoutJS Starter</a> - Publisher Site<br><a href="http://www.amazon.com/KnockoutJS-Starter-ebook/dp/B00AC1HDJS/">KnockoutJS Starter</a> - Amazon</p>\n',
        _id: 'ci8xkju9k00082wtbd09d5pxq',
        path: [Getter],
        permalink: [Getter],
        full_source: [Getter],
        asset_dir: [Getter],
        tags: [Getter],
        categories: [Getter],
        prev: [Object],
        next: [Circular] },
     next: 
      { title: 'SQL Script Generation Column Names',
        date: [Object],
        _content: '\nWhen I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.\n\nOur head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.\n\nThe PROC allows you to specify:\n- Table Name (as it appears in the SYS.tables table)\n- ‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)\n- A ColumnName prefix (for doing table aliases)\n- A table schema (if you have other table schema’s besides ‘dbo’)\n\nHere’s the code (make sure to look at the bottom):\n```sql\nUSE [master]\nGO\nSET ANSI_NULLS ON\nGO\nSET QUOTED_IDENTIFIER ON\nGO\nCREATE PROCEDURE [dbo].[sp_listcolumns]\n    @table  SYSNAME,\n    @list   CHAR(1) = \'L\',\n    @prefix SYSNAME = \'\',\n    @schema SYSNAME = \'dbo\'\nAS\nBEGIN\nSET NOCOUNT ON;\nSET QUOTED_IDENTIFIER OFF\n\nDECLARE @columnlist NVARCHAR(4000)\n       ,@colctr INT = 1\n       ,@sqlcmd NVARCHAR(500)\n\nCREATE TABLE #column\n(\n    ColumnName NVARCHAR(256),\n    Ordinal INT\n)\n\nCREATE UNIQUE CLUSTERED INDEX IC_ColumnList99 ON #column (Ordinal)\n\nSET @columnlist =    \'\'\nSET @table =        LTRIM(RTRIM(@table))\nSET @list =         LTRIM(RTRIM(@list))\nSET @prefix =       LTRIM(RTRIM(@prefix))\nSET @schema =       LTRIM(RTRIM(@schema))\n\nINSERT INTO #column (ColumnName, Ordinal)\nSELECT  \'[\'+LTRIM(RTRIM(COLUMN_NAME))+\']\', ORDINAL_POSITION\nFROM    INFORMATION_SCHEMA.COLUMNS\nWHERE   TABLE_NAME = @table AND\n        TABLE_SCHEMA = @schema\nORDER BY ORDINAL_POSITION\n\n-- Check to make sure we actually got usuable input from the User\nIF ((SELECT COUNT(*) FROM #column) = 0)\nRAISERROR(\'Bad Table Information - Please Try Again\', 16, 1, 1)\n\nIF(@prefix <> \'\')\nBEGIN\n    UPDATE #column\n    SET    ColumnName = @prefix + ColumnName\nEND\n\nIF(@list = \'L\')\n    BEGIN\n        -- If it is \'L\' just append a \',\' to each line, output would be:\n        -- TestCol1,\n        -- TestCol2\n\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\' + CHAR(10)\n        FROM    #column C\n    END\nELSE\n    BEGIN\n        -- else we output a \'w\' where it just a \',\' separated list of Column names\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\'\n        FROM    #column C\n\n        -- Remove the last comma\n        SET @columnlist = LEFT(@columnlist,LEN(@columnlist) - 1)\n    END\n\n-- Output the results so that they can be nicely copy\n-- and pasted from the comment window\nPRINT(@columnlist)\n\nSET QUOTED_IDENTIFIER ON\nSET NOCOUNT OFF\n\nEND\n```\n\nLastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in\n\n```sql\nEXECUTE sp_MS_marksystemobject \'sp_listcolumns\'\n```\n\nAfter we have this proc build and added, we can get output like this:\n```sql\nCREATE TABLE dbo.Test\n(\n    Id UNIQUEIDENTIFIER\n    ,TestCol1 NVARCHAR(64)\n    ,TestCol2 INT\n    ,TestCol3 BIT\n)\nGO\n\nsp_listcolumns \'test\'\n\n--Outputs:\n[Id],\n[TestCol1],\n[TestCol2],\n[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\'\n\n--Outputs:\n[Id],[TestCol1],[TestCol2],[TestCol3]\n--\n\nsp_listcolumns \'test\',\'l\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],\ntestTable.[TestCol1],\ntestTable.[TestCol2],\ntestTable.[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]\n```',
        source: '_posts/2011-08-08-sql-script-generation-column-names.md',
        raw: 'title: "SQL Script Generation Column Names"\ndate: 2011-08-8 12:00:00\ncategories: \n    - Development\ntags:\n    - SQL\n---\n\nWhen I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.\n\nOur head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.\n\nThe PROC allows you to specify:\n- Table Name (as it appears in the SYS.tables table)\n- ‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)\n- A ColumnName prefix (for doing table aliases)\n- A table schema (if you have other table schema’s besides ‘dbo’)\n\nHere’s the code (make sure to look at the bottom):\n```sql\nUSE [master]\nGO\nSET ANSI_NULLS ON\nGO\nSET QUOTED_IDENTIFIER ON\nGO\nCREATE PROCEDURE [dbo].[sp_listcolumns]\n    @table  SYSNAME,\n    @list   CHAR(1) = \'L\',\n    @prefix SYSNAME = \'\',\n    @schema SYSNAME = \'dbo\'\nAS\nBEGIN\nSET NOCOUNT ON;\nSET QUOTED_IDENTIFIER OFF\n\nDECLARE @columnlist NVARCHAR(4000)\n       ,@colctr INT = 1\n       ,@sqlcmd NVARCHAR(500)\n\nCREATE TABLE #column\n(\n    ColumnName NVARCHAR(256),\n    Ordinal INT\n)\n\nCREATE UNIQUE CLUSTERED INDEX IC_ColumnList99 ON #column (Ordinal)\n\nSET @columnlist =    \'\'\nSET @table =        LTRIM(RTRIM(@table))\nSET @list =         LTRIM(RTRIM(@list))\nSET @prefix =       LTRIM(RTRIM(@prefix))\nSET @schema =       LTRIM(RTRIM(@schema))\n\nINSERT INTO #column (ColumnName, Ordinal)\nSELECT  \'[\'+LTRIM(RTRIM(COLUMN_NAME))+\']\', ORDINAL_POSITION\nFROM    INFORMATION_SCHEMA.COLUMNS\nWHERE   TABLE_NAME = @table AND\n        TABLE_SCHEMA = @schema\nORDER BY ORDINAL_POSITION\n\n-- Check to make sure we actually got usuable input from the User\nIF ((SELECT COUNT(*) FROM #column) = 0)\nRAISERROR(\'Bad Table Information - Please Try Again\', 16, 1, 1)\n\nIF(@prefix <> \'\')\nBEGIN\n    UPDATE #column\n    SET    ColumnName = @prefix + ColumnName\nEND\n\nIF(@list = \'L\')\n    BEGIN\n        -- If it is \'L\' just append a \',\' to each line, output would be:\n        -- TestCol1,\n        -- TestCol2\n\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\' + CHAR(10)\n        FROM    #column C\n    END\nELSE\n    BEGIN\n        -- else we output a \'w\' where it just a \',\' separated list of Column names\n        UPDATE  C\n        SET     @columnlist = @columnlist + C.ColumnName + \',\'\n        FROM    #column C\n\n        -- Remove the last comma\n        SET @columnlist = LEFT(@columnlist,LEN(@columnlist) - 1)\n    END\n\n-- Output the results so that they can be nicely copy\n-- and pasted from the comment window\nPRINT(@columnlist)\n\nSET QUOTED_IDENTIFIER ON\nSET NOCOUNT OFF\n\nEND\n```\n\nLastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in\n\n```sql\nEXECUTE sp_MS_marksystemobject \'sp_listcolumns\'\n```\n\nAfter we have this proc build and added, we can get output like this:\n```sql\nCREATE TABLE dbo.Test\n(\n    Id UNIQUEIDENTIFIER\n    ,TestCol1 NVARCHAR(64)\n    ,TestCol2 INT\n    ,TestCol3 BIT\n)\nGO\n\nsp_listcolumns \'test\'\n\n--Outputs:\n[Id],\n[TestCol1],\n[TestCol2],\n[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\'\n\n--Outputs:\n[Id],[TestCol1],[TestCol2],[TestCol3]\n--\n\nsp_listcolumns \'test\',\'l\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],\ntestTable.[TestCol1],\ntestTable.[TestCol2],\ntestTable.[TestCol3],\n--\n\nsp_listcolumns \'test\',\'w\',\'testTable.\'\n\n--Outputs:\ntestTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]\n```',
        slug: 'sql-script-generation-column-names',
        published: true,
        updated: [Object],
        comments: true,
        layout: 'post',
        photos: [],
        link: '',
        content: '<p>When I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.</p>\n<p>Our head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.</p>\n<p>The PROC allows you to specify:</p>\n<ul>\n<li>Table Name (as it appears in the SYS.tables table)</li>\n<li>‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)</li>\n<li>A ColumnName prefix (for doing table aliases)</li>\n<li>A table schema (if you have other table schema’s besides ‘dbo’)</li>\n</ul>\n<p>Here’s the code (make sure to look at the bottom):<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">USE</span> [<span class="keyword">master</span>]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[sp_listcolumns]</span><br><span class="line">    @<span class="keyword">table</span>  SYSNAME,</span><br><span class="line">    @list   <span class="built_in">CHAR</span>(<span class="number">1</span>) = <span class="string">\'L\'</span>,</span><br><span class="line">    @prefix SYSNAME = <span class="string">\'\'</span>,</span><br><span class="line">    @<span class="keyword">schema</span> SYSNAME = <span class="string">\'dbo\'</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SET</span> QUOTED_IDENTIFIER OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @columnlist <span class="keyword">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">       ,@colctr <span class="built_in">INT</span> = <span class="number">1</span></span><br><span class="line">       ,@sqlcmd <span class="keyword">NVARCHAR</span>(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #<span class="keyword">column</span></span><br><span class="line">(</span><br><span class="line">    ColumnName <span class="keyword">NVARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    Ordinal <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> IC_ColumnList99 <span class="keyword">ON</span> #<span class="keyword">column</span> (Ordinal)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @columnlist =    <span class="string">\'\'</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">table</span> =        <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">table</span>))</span><br><span class="line"><span class="keyword">SET</span> @list =         <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@list))</span><br><span class="line"><span class="keyword">SET</span> @prefix =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@prefix))</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">schema</span> =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">schema</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> #<span class="keyword">column</span> (ColumnName, Ordinal)</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">\'[\'</span>+<span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(COLUMN_NAME))+<span class="string">\']\'</span>, ORDINAL_POSITION</span><br><span class="line"><span class="keyword">FROM</span>    INFORMATION_SCHEMA.<span class="keyword">COLUMNS</span></span><br><span class="line"><span class="keyword">WHERE</span>   TABLE_NAME = @<span class="keyword">table</span> <span class="keyword">AND</span></span><br><span class="line">        TABLE_SCHEMA = @<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDINAL_POSITION</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check to make sure we actually got usuable input from the User</span></span><br><span class="line"><span class="keyword">IF</span> ((<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> #<span class="keyword">column</span>) = <span class="number">0</span>)</span><br><span class="line">RAISERROR(<span class="string">\'Bad Table Information - Please Try Again\'</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@prefix &lt;&gt; <span class="string">\'\'</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> #<span class="keyword">column</span></span><br><span class="line">    <span class="keyword">SET</span>    ColumnName = @prefix + ColumnName</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@list = <span class="string">\'L\'</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- If it is \'L\' just append a \',\' to each line, output would be:</span></span><br><span class="line">        <span class="comment">-- TestCol1,</span></span><br><span class="line">        <span class="comment">-- TestCol2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span> + <span class="built_in">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- else we output a \'w\' where it just a \',\' separated list of Column names</span></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span></span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Remove the last comma</span></span><br><span class="line">        <span class="keyword">SET</span> @columnlist = <span class="keyword">LEFT</span>(@columnlist,<span class="keyword">LEN</span>(@columnlist) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output the results so that they can be nicely copy</span></span><br><span class="line"><span class="comment">-- and pasted from the comment window</span></span><br><span class="line">PRINT(@columnlist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure></p>\n<p>Lastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in</p>\n<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">EXECUTE</span> sp_MS_marksystemobject <span class="string">\'sp_listcolumns\'</span></span></span><br></pre></td></tr></table></figure>\n<p>After we have this proc build and added, we can get output like this:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Test</span><br><span class="line">(</span><br><span class="line">    Id UNIQUEIDENTIFIER</span><br><span class="line">    ,TestCol1 <span class="keyword">NVARCHAR</span>(<span class="number">64</span>)</span><br><span class="line">    ,TestCol2 <span class="built_in">INT</span></span><br><span class="line">    ,TestCol3 <span class="built_in">BIT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],</span><br><span class="line">[TestCol1],</span><br><span class="line">[TestCol2],</span><br><span class="line">[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],[TestCol1],[TestCol2],[TestCol3]</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'l\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],</span><br><span class="line">testTable.[TestCol1],</span><br><span class="line">testTable.[TestCol2],</span><br><span class="line">testTable.[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]</span></span><br></pre></td></tr></table></figure></p>\n',
        excerpt: '',
        more: '<p>When I’m doing heavy database development, one of the biggest annoyances I run into is having to hand key (or clumsily generate) the column names for stored procedures (especially those containing MERGE statements). I really wished I could use something to quickly output the columns to text so I could copy and paste the formatted column names as I needed them… well voila.</p>\n<p>Our head DBA always has a few tricks up his sleeve, so we setup a system stored procedure to print out the column names (comma separated of course) for what ever table we want.</p>\n<p>The PROC allows you to specify:</p>\n<ul>\n<li>Table Name (as it appears in the SYS.tables table)</li>\n<li>‘L’ or ‘W’ depending if you want the columns listed with a {CRLF} after each column (‘L’) or all on one line (‘W)</li>\n<li>A ColumnName prefix (for doing table aliases)</li>\n<li>A table schema (if you have other table schema’s besides ‘dbo’)</li>\n</ul>\n<p>Here’s the code (make sure to look at the bottom):<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">USE</span> [<span class="keyword">master</span>]</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> ANSI_NULLS <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> [dbo].[sp_listcolumns]</span><br><span class="line">    @<span class="keyword">table</span>  SYSNAME,</span><br><span class="line">    @list   <span class="built_in">CHAR</span>(<span class="number">1</span>) = <span class="string">\'L\'</span>,</span><br><span class="line">    @prefix SYSNAME = <span class="string">\'\'</span>,</span><br><span class="line">    @<span class="keyword">schema</span> SYSNAME = <span class="string">\'dbo\'</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SET</span> QUOTED_IDENTIFIER OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @columnlist <span class="keyword">NVARCHAR</span>(<span class="number">4000</span>)</span><br><span class="line">       ,@colctr <span class="built_in">INT</span> = <span class="number">1</span></span><br><span class="line">       ,@sqlcmd <span class="keyword">NVARCHAR</span>(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> #<span class="keyword">column</span></span><br><span class="line">(</span><br><span class="line">    ColumnName <span class="keyword">NVARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    Ordinal <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> IC_ColumnList99 <span class="keyword">ON</span> #<span class="keyword">column</span> (Ordinal)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @columnlist =    <span class="string">\'\'</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">table</span> =        <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">table</span>))</span><br><span class="line"><span class="keyword">SET</span> @list =         <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@list))</span><br><span class="line"><span class="keyword">SET</span> @prefix =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@prefix))</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">schema</span> =       <span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(@<span class="keyword">schema</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> #<span class="keyword">column</span> (ColumnName, Ordinal)</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">\'[\'</span>+<span class="keyword">LTRIM</span>(<span class="keyword">RTRIM</span>(COLUMN_NAME))+<span class="string">\']\'</span>, ORDINAL_POSITION</span><br><span class="line"><span class="keyword">FROM</span>    INFORMATION_SCHEMA.<span class="keyword">COLUMNS</span></span><br><span class="line"><span class="keyword">WHERE</span>   TABLE_NAME = @<span class="keyword">table</span> <span class="keyword">AND</span></span><br><span class="line">        TABLE_SCHEMA = @<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ORDINAL_POSITION</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Check to make sure we actually got usuable input from the User</span></span><br><span class="line"><span class="keyword">IF</span> ((<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> #<span class="keyword">column</span>) = <span class="number">0</span>)</span><br><span class="line">RAISERROR(<span class="string">\'Bad Table Information - Please Try Again\'</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@prefix &lt;&gt; <span class="string">\'\'</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> #<span class="keyword">column</span></span><br><span class="line">    <span class="keyword">SET</span>    ColumnName = @prefix + ColumnName</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span>(@list = <span class="string">\'L\'</span>)</span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- If it is \'L\' just append a \',\' to each line, output would be:</span></span><br><span class="line">        <span class="comment">-- TestCol1,</span></span><br><span class="line">        <span class="comment">-- TestCol2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span> + <span class="built_in">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">BEGIN</span></span><br><span class="line">        <span class="comment">-- else we output a \'w\' where it just a \',\' separated list of Column names</span></span><br><span class="line">        <span class="keyword">UPDATE</span>  C</span><br><span class="line">        <span class="keyword">SET</span>     @columnlist = @columnlist + C.ColumnName + <span class="string">\',\'</span></span><br><span class="line">        <span class="keyword">FROM</span>    #<span class="keyword">column</span> C</span><br><span class="line"></span><br><span class="line">        <span class="comment">-- Remove the last comma</span></span><br><span class="line">        <span class="keyword">SET</span> @columnlist = <span class="keyword">LEFT</span>(@columnlist,<span class="keyword">LEN</span>(@columnlist) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Output the results so that they can be nicely copy</span></span><br><span class="line"><span class="comment">-- and pasted from the comment window</span></span><br><span class="line">PRINT(@columnlist)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> QUOTED_IDENTIFIER <span class="keyword">ON</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT OFF</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure></p>\n<p>Lastly we need to add this as a system proc, or else it never changes its scope to the DB you are running it in</p>\n<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">EXECUTE</span> sp_MS_marksystemobject <span class="string">\'sp_listcolumns\'</span></span></span><br></pre></td></tr></table></figure>\n<p>After we have this proc build and added, we can get output like this:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Test</span><br><span class="line">(</span><br><span class="line">    Id UNIQUEIDENTIFIER</span><br><span class="line">    ,TestCol1 <span class="keyword">NVARCHAR</span>(<span class="number">64</span>)</span><br><span class="line">    ,TestCol2 <span class="built_in">INT</span></span><br><span class="line">    ,TestCol3 <span class="built_in">BIT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],</span><br><span class="line">[TestCol1],</span><br><span class="line">[TestCol2],</span><br><span class="line">[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">[Id],[TestCol1],[TestCol2],[TestCol3]</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'l\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],</span><br><span class="line">testTable.[TestCol1],</span><br><span class="line">testTable.[TestCol2],</span><br><span class="line">testTable.[TestCol3],</span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line">sp_listcolumns <span class="string">\'test\'</span>,<span class="string">\'w\'</span>,<span class="string">\'testTable.\'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Outputs:</span></span><br><span class="line">testTable.[Id],testTable.[TestCol1],testTable.[TestCol2],testTable.[TestCol3]</span></span><br></pre></td></tr></table></figure></p>\n',
        _id: 'ci8xkju9200002wtb0dnckq7o',
        path: [Getter],
        permalink: [Getter],
        full_source: [Getter],
        asset_dir: [Getter],
        tags: [Getter],
        categories: [Getter],
        prev: [Circular] } },
  lang: 'en-US',
  canonical_path: '2011/08/sql-script-generation-column-names.html' }
--!>


</body>
</html>